================================================================================

Author intent:
- Build a Svelte-native editor core (TS) + renderer + UI.
- Keep the "engine" framework-agnostic so Web + Tauri share it.
- Defer collaboration until single-player is correct.

Conventions:
- [ ] Task
- (DoD) Definition of Done for the milestone
- Files shown are ideas, not requirements

================================================================================
1. Milestone A: Repo skeleton + dev loop                                  *wb-A*
================================================================================

Goal: a monorepo that can run a blank canvas in web + desktop.

[ ] Create workspace:
    - /apps/web (SvelteKit)
    - /apps/desktop (Tauri wrapper)
    - /packages/core (pure TS engine)
    - /packages/renderer (Canvas2D renderer)

[ ] Add TypeScript config(s):
    - one shared tsconfig.base.json
    - package-level tsconfig.json extends base

[ ] Add lint/format:
    - eslint + prettier
    - one command: pnpm lint / pnpm fmt

[ ] Add test runner for core:
    - vitest in /packages/core
    - one command: pnpm test

[ ] Add CI:
    - install, lint, test (core only)

(DoD):
- `pnpm dev:web` shows an empty page with a <canvas>.
- `pnpm dev:desktop` launches a Tauri window that shows the same canvas.
- `pnpm test` runs at least 1 passing core test.

================================================================================
2. Milestone B: Math + coordinate systems                                 *wb-B*
================================================================================

Camera math, matrix utilities, and transforms are fully implemented and verified
so world and screen coordinates map precisely.

================================================================================
3. Milestone C: Document model (records)                                  *wb-C*
================================================================================

Document/page/shape/binding records plus validation let the editor serialize and
reason about drawings safely.

================================================================================
4. Milestone D: Store + selectors (reactive core)                         *wb-D*
================================================================================

The reactive store, invariants, and selectors supply deterministic state streams
for both renderer and UI subscribers.

================================================================================
5. Milestone E: Canvas renderer (read-only)                               *wb-E*
================================================================================

The renderer now draws the document via Canvas2D with camera transforms,
DPI scaling, text sizing, and selection outlines.

================================================================================
6. Milestone F: Hit testing (picking)                                     *wb-F*
================================================================================

Geometry helpers compute bounds and intersections so hit testing can always
return the topmost shape under the cursor.

================================================================================
7. Milestone G: Input system (pointer + keyboard)                         *wb-G*
================================================================================

Pointer and keyboard adapters now normalize events, map them into actions, and
feed the editor consistently across platforms.

================================================================================
8. Milestone H: Tool state machine (foundation)                           *wb-H*
================================================================================

Tool interfaces and the router manage lifecycle hooks so each tool is an
explicit, testable state machine.


================================================================================
9. Milestone I: Select/move tool (MVP interaction)                        *wb-I*
================================================================================

Selection logic handles hit selection, marquee, dragging, deletion, and escape
so shapes can be moved reliably.

================================================================================
10. Milestone J: Create basic shapes via tools                            *wb-J*
================================================================================

Rect, ellipse, line, arrow, and text tools now create shapes via click-drag
interactions with proper finalize/cancel behavior.

================================================================================
11. Milestone K: Bindings for arrows (v0)                                 *wb-K*
================================================================================

Arrow endpoints bind to target shapes and stay attached by recalculating anchors
whenever shapes move.

================================================================================
12. Milestone L: History (undo/redo)                                      *wb-L*
================================================================================

All document-affecting actions run through undoable commands with history stacks
and keyboard shortcuts.

================================================================================
13. Milestone M: Persistence (web) via Dexie + History integration        *wb-M*
================================================================================

Document changes now persist to IndexedDB via Dexie with migrations, repo API,
and history-driven syncing.

================================================================================
14. Milestone N: Status Bar (Editor HUD)                                  *wb-N*
================================================================================

Goal:
Add a bottom status bar that surfaces the "always-useful" editor telemetry:
cursor position, zoom, active tool/mode, selection summary, and persistence
state - with a clean core → UI boundary.

Design inspirations:
- Zoom controls commonly expose percentage + "zoom to fit/selection" shortcuts.
Svelte integration detail:
- Use $effect to subscribe/unsubscribe to external sources (runs client-side;
  cleanup function runs on re-run/unmount).

------------------------------------------------------------------------------
N1. Define the StatusBar view model (core, pure TS)
------------------------------------------------------------------------------

/packages/core/src/ui/statusbar/types.ts
[ ] Define StatusBarVM (single object the UI renders):
    - cursorWorld: { x, y }         " world coords (always)
    - cursorScreen: { x, y }?       " optional dev-only
    - zoomPct: number               " e.g. 100, 67, 250
    - toolId: ToolId                " select/rect/pen/...
    - mode: string                  " 'idle'|'dragging'|'panning'|'text-edit'
    - selection:
        - count: number
        - kind?: string             " optional: 'rect', 'mixed', etc.
        - bounds?: { w, h }         " optional v1
    - snap:
        - enabled: boolean
        - gridSize?: number         " if grid enabled
        - angleStepDeg?: number     " if angle snapping exists
    - persistence:
        - backend: 'indexeddb'
        - state: 'saved'|'saving'|'error'
        - lastSavedAt?: number      " epoch ms
        - pendingWrites?: number    " queue depth if you batch writes
        - errorMsg?: string

Notes:
- This VM is intentionally READ-ONLY and derived from existing editor state,
  input state, and persistence sink state.

(DoD):
- StatusBarVM compiles and is stable enough to render even before UI exists.

------------------------------------------------------------------------------
N2. Provide selectors / derivations for StatusBarVM
------------------------------------------------------------------------------

/packages/core/src/ui/statusbar/selectors.ts
[ ] Implement pure functions:
    - getZoomPct(state) -> number
    - getToolId(state) -> ToolId
    - getSelectionSummary(state) -> { count, kind?, bounds? }
    - getSnapSummary(state) -> snap summary (default safe values)

Cursor position source:
[ ] Define a minimal CursorState in core (NOT persisted):
    - cursorWorld: Vec2
    - cursorScreen?: Vec2
    - lastMoveAt: number

[ ] Add updateCursor(world, screen?) action + reducer handler (or direct setter)
    that ONLY touches CursorState (no history command, no persistence).

(DoD):
- You can compute StatusBarVM from (EditorState + CursorState + PersistState).

------------------------------------------------------------------------------
N3. Wire cursor updates from pointer movement (apps/web)
------------------------------------------------------------------------------

/apps/web/src/lib/pointer.ts
[ ] On pointermove (or mousemove when not captured):
    - compute world coords using camera.screenToWorld
    - dispatch updateCursor(world, screen)

Performance:
[ ] Throttle cursor updates:
    - v0: requestAnimationFrame coalescing (only publish latest per frame)
    - avoid flooding render/history/persistence

(DoD):
- Cursor world coordinates update smoothly while moving the mouse.

------------------------------------------------------------------------------
N4. Add persistence status signals (Dexie + persistence sink integration)
------------------------------------------------------------------------------

Goal:
Expose persistence state without touching the history system (Milestone L is
done; persistence is already hooked to history in Milestone M).

/apps/web/src/lib/status.ts
[ ] Extend your persistence sink (from Milestone M) to expose a small status:
    - pendingWrites counter (increment on enqueue, decrement on commit)
    - lastSavedAt timestamp (set on successful commit)
    - lastError (set on failed commit)
[ ] Use Dexie liveQuery to observe the current board’s updatedAt from IndexedDB
    and reflect it in the UI (helps confirm persisted state across tabs).

(DoD):
- Status bar can show: "Saving…" when pendingWrites > 0, and "Saved" with time
  when pendingWrites reaches 0.

------------------------------------------------------------------------------
N5. Implement StatusBar.svelte using runes
------------------------------------------------------------------------------

/apps/web/src/lib/components/StatusBar.svelte
[ ] Render left → right (suggested):
    - Tool + mode
    - Cursor: X,Y (world)
    - Selection summary
    - Snap/grid summary
    - Zoom %
    - Save state ("Saved 3s ago" / "Saving…" / "Error")

[ ] Consume state via runes:
    - keep a local $state(snapshot) for EditorState
    - keep a local $state(cursor) for CursorState
    - keep a local $state(persist) for PersistStatus

Subscriptions:
[ ] Use $effect to subscribe to any external streams and return cleanup
    unsubscribe.

Formatting:
[ ] Cursor formatting:
    - v0: integers
    - v1: configurable precision (e.g. 0.1 units when zoomed in)

(DoD):
- Status bar is visible, updates live, and never causes noticeable jank.

------------------------------------------------------------------------------
N6. Interactions (small, high-value)
------------------------------------------------------------------------------

Zoom control:
[ ] Clicking zoomPct opens a tiny menu:
    - 50%, 100%, 200%
    - Zoom to fit
    - Zoom to selection
(Inspiration: zoom/view options + shortcuts in Figma/FigJam.)

Snap toggles:
[ ] Add quick toggles (optional v0, recommended v1):
    - snap enabled
    - grid enabled

(DoD):
- Zoom is discoverable and controllable from the status bar.

------------------------------------------------------------------------------
N7. Tests
------------------------------------------------------------------------------

Core unit tests (/packages/core/test/statusbar.test.ts):
[ ] getZoomPct returns expected values from camera zoom
[ ] selection summary is correct (0, 1, many)
[ ] snap summary defaults safe when features disabled

Web integration tests (optional v0):
[ ] cursor update throttling: 100 pointermoves in a tick results in <= 1 state
    publication per frame (if you implement rAF coalescing)

Persistence tests (web):
[ ] pendingWrites transitions: 0 -> N -> 0 yields state 'saving' then 'saved'
[ ] error sets 'error' state and preserves lastSavedAt

------------------------------------------------------------------------------
Definition of Done
------------------------------------------------------------------------------

- Status bar shows:
    - cursor world position
    - zoom percentage
    - active tool/mode
    - selection count
    - persistence state (Saved/Saving/Error + lastSavedAt)
- Cursor updates are throttled and do not spam history or persistence.
- UI subscriptions use $effect with cleanup.

================================================================================
15. Milestone O: Export (PNG/SVG)                                         *wb-O*
================================================================================

Goal: export drawings as shareable artifacts.

[ ] Implement exportViewportToPNG(canvas) (screen export)
[ ] Implement exportSelectionToPNG (render selection bounds)
[ ] Implement SVG export for basic shapes:
    - rect/ellipse/line/arrow/text
    - camera transform baked into output or removed-pick one and document
    - show bottom bar, expandable with copyable SVG code

Tests:
[ ] exported SVG parses and contains expected elements

(DoD):
- One-click export works in both web and desktop.

================================================================================
16. Milestone P: Desktop packaging (Tauri)                                *wb-P*
================================================================================

Goal: same app works as a desktop app with filesystem access.

Tauri + SvelteKit integration:
[ ] Configure SvelteKit for static/SPA output
[ ] Ensure SSR is disabled for desktop build
[ ] Configure Tauri to load the built assets

File dialogs + FS:
[ ] Implement "Save As…" using Tauri dialog + fs APIs
[ ] Implement "Open…" using Tauri dialog + fs APIs
[ ] Add recent files list (v0: store paths in Tauri local storage)

(DoD):
- Desktop app opens/saves JSON files on disk and reopens them correctly.

================================================================================
17. Milestone Q: Performance + big docs (pragmatic)                       *wb-Q*
================================================================================

Goal: the editor stays responsive with many shapes.

[ ] Add spatial index (v0: simple grid buckets):
    - rebuild index on doc changes
    - query nearby shapes for hit testing
[ ] Add view culling:
    - compute viewport bounds in world space
    - render only shapes whose bounds intersect viewport
[ ] Reduce redraw frequency:
    - rAF only while dirty
    - optionally batch multiple store updates into one redraw
[ ] Add microbench harness:
    - generate 10k shapes doc
    - measure hit test and render time

(DoD):
- 10k simple shapes pans/zooms smoothly on a typical machine.

================================================================================
18. Milestone R: File Browser (web: Dexie inspector, desktop: FS)         *wb-R*
================================================================================

Goal: A unified "Open board" experience:
- Web: browse Dexie-backed boards + a useful persistence/migration inspector
- Desktop: browse real directories/files (native file browser semantics)

--------------------------------------------------------------------------------
R1. Shared UX contracts
--------------------------------------------------------------------------------

/packages/core/src/persist/DocRepo.ts:
[ ] Define DocRepo interface (web + desktop):
    - listBoards(): Promise<BoardMeta[]>
    - createBoard(name): Promise<string>
    - openBoard(id): Promise<void>
    - renameBoard(id, name): Promise<void>
    - deleteBoard(id): Promise<void>

[ ] Define FileBrowserViewModel:
    - query, filteredBoards, selectedId
    - actions: open/create/rename/delete

(DoD):
- Svelte UI can render the browser purely from the ViewModel.

--------------------------------------------------------------------------------
R2. Web: Boards list + Dexie "Inspector" drawer
--------------------------------------------------------------------------------

/apps/web/src/lib/filebrowser/FileBrowser.svelte:
[ ] Boards panel:
    - listBoards() -> render
    - search filter
    - open / create / rename / delete

Inspector drawer (selected board):
[ ] Show "Storage: IndexedDB (Dexie)"
[ ] Show schema info:
    - declared schema version (your constant)
    - installed schema version (best-effort display)
[ ] Show board-level stats (computed live):
    - row counts: pages/shapes/bindings for this board (Option A)
      OR doc size bytes for docs row (Option B)
    - last updatedAt
[ ] Show migration info:
    - list applied migrations from migrations table (id + appliedAt)
    - show "pending" migrations if any (based on known list vs applied)

Safe deletes:
[ ] deleteBoard must be a single atomic transaction (boards + related tables)

(DoD):
- Web: you can browse boards, open one, and verify migrations + row counts.

--------------------------------------------------------------------------------
R3. Desktop: real directory + files (Tauri)
--------------------------------------------------------------------------------

[ ] Add "Workspace folder" concept:
    - pick directory
    - remember last workspace path
[ ] Implement directory listing:
    - v0: show *.Inkfinite.json files in workspace
    - v1: tree view with folders
[ ] Implement file actions:
    - New: create new file
    - Rename: rename file
    - Delete: delete file
    - Open: load file into editor
    - Export: save JSON

(DoD):
- Desktop: pick a folder, browse files, open/save boards from disk.

--------------------------------------------------------------------------------
R4. Parity behaviors
--------------------------------------------------------------------------------

[ ] Same shortcuts:
    - Ctrl/Cmd+O opens file browser
    - Ctrl/Cmd+N creates board
[ ] Consistent metadata display:
    - name + updatedAt in both modes

(DoD):
- Web and desktop feel like the same app, with storage differences made explicit.

================================================================================
19. Milestone S: Quality polish (what makes it feel "real")               *wb-S*
================================================================================

Goal: the UX crosses the "this is legit" threshold.

[ ] Snapping:
    - snap move to grid
    - snap to other shape edges/centers
[ ] Handles:
    - resize handles for rect/ellipse
    - rotate handle
    - cursor affordances
[ ] Keyboard affordances:
    - nudge with arrow keys
    - duplicate (Ctrl/Cmd+D)
    - bring forward/back
[ ] Accessibility:
    - tool buttons navigable with keyboard
    - visible focus states
    - ARIA labels for controls

(DoD):
- A user can comfortably draw and edit without surprises.

================================================================================
References (URLs)                                                      *wb-refs*
================================================================================

tldraw conceptual references (inspiration only):
- https://tldraw.dev/docs/shapes
- https://tldraw.dev/docs/editor
- https://tldraw.dev/reference/editor/Editor

SvelteKit + Tauri packaging:
- https://v2.tauri.app/start/frontend/sveltekit/
- https://svelte.dev/docs/kit/adapter-static
- https://tauri.app/v1/guides/getting-started/setup/sveltekit/

Canvas/infinite-canvas performance ideas:
- https://antv.vision/infinite-canvas-tutorial/guide/lesson-008
- https://harrisonmilbradt.com/blog/canvas-panning-and-zooming
