=============================================================================
Author intent:
- Build a Svelte-native editor core (TS) + renderer + UI.
- Keep the "engine" framework-agnostic so Web + Tauri share it.
- Defer collaboration until single-player is correct.

Conventions:
- [ ] Task
- (DoD) Definition of Done for the milestone
- Files shown are ideas, not requirements
==============================================================================
1. Milestone A: Repo skeleton + dev loop                            *wb-A*
==============================================================================

Goal: a monorepo that can run a blank canvas in web + desktop.

[ ] Create workspace:
    - /apps/web (SvelteKit)
    - /apps/desktop (Tauri wrapper)
    - /packages/core (pure TS engine)
    - /packages/renderer (Canvas2D renderer)

[ ] Add TypeScript config(s):
    - one shared tsconfig.base.json
    - package-level tsconfig.json extends base

[ ] Add lint/format:
    - eslint + prettier
    - one command: pnpm lint / pnpm fmt

[ ] Add test runner for core:
    - vitest in /packages/core
    - one command: pnpm test

[ ] Add CI:
    - install, lint, test (core only)

(DoD):
- `pnpm dev:web` shows an empty page with a <canvas>.
- `pnpm dev:desktop` launches a Tauri window that shows the same canvas.
- `pnpm test` runs at least 1 passing core test.

==============================================================================
2. Milestone B: Math + coordinate systems                            *wb-B*
==============================================================================

Goal: a correct, testable camera transform (world <-> screen).

Core primitives (/packages/core/src/math.ts):
[x] Define Vec2 { x, y } + helpers:
    - add, sub, mulScalar, len, normalize, dot
[x] Define Box2 { min: Vec2, max: Vec2 }:
    - fromPoints, containsPoint, intersectsBox
[x] Define Mat3 (2D affine) or equivalent:
    - identity
    - translate(tx, ty)
    - scale(sx, sy)
    - rotate(theta)
    - multiply(a, b)
    - transformPoint(m, p)

Camera (/packages/core/src/camera.ts):
[x] Define Camera { x, y, zoom } (world origin + scale)
[x] Implement worldToScreen(camera, p)
[x] Implement screenToWorld(camera, p)
[x] Implement cameraPan(camera, deltaScreen) -> camera'
[x] Implement cameraZoomAt(camera, factor, anchorScreenPoint) -> camera'

Tests (/packages/core/tests/camera.test.ts):
[x] worldToScreen(screenToWorld(p)) round-trip within epsilon
[x] zoomAt keeps anchor point stable (screen position unchanged)
[x] pan moves world under cursor as expected

(DoD):
- All math/camera functions are unit-tested and pass.

==============================================================================
3. Milestone C: Document model (records)                              *wb-C*
==============================================================================

Goal: define the minimal data model that can represent a drawing.

Records & ID (/packages/core/src/model):
[x] Implement createId(prefix) -> uuid (v4)
[x] Define PageRecord { id, name, shapeIds: string[] }
[x] Define ShapeRecord base:
    - id, type, pageId
    - x, y, rot
    - props: object (type-specific)

[x] Define shape types (minimal):
    - rect: { w, h, fill, stroke, radius }
    - ellipse: { w, h, fill, stroke }
    - line: { a: Vec2, b: Vec2, stroke, width }
    - arrow: { a: Vec2, b: Vec2, stroke, width }
    - text: { text, fontSize, fontFamily, color, w? }

[x] Define BindingRecord (for arrow endpoints):
    - id, type: "arrow-end"
    - fromShapeId (arrow id)
    - toShapeId (target shape id)
    - handle: "start" | "end"
    - anchor: e.g. { kind: "center" } for v0

Validation:
[x] validateDoc(doc) -> { ok | errors[] }

(DoD):
- You can serialize a doc with a page + 1 shape to JSON and validate it.

==============================================================================
4. Milestone D: Store + selectors (reactive core)                      *wb-D*
==============================================================================

Goal: a fast, deterministic state container for the editor using RxJS

Store (/packages/core/src/reactivity.ts) - RxJS + SvelteKit (runes) friendly

Core types:
[x] Define EditorState:
    - doc: { pages, shapes, bindings }
    - ui: { currentPageId, selectionIds: string[], toolId: ToolId }
    - camera: { x, y, zoom }

RxJS store (BehaviorSubject-backed):
[x] Implement createEditorStore(initial: EditorState) that exposes:
    - state$: Observable<EditorState>         (read stream)
    - getState(): EditorState                (sync snapshot)
    - setState(updater: (s) => s): void      (mutation API)
    - subscribe(listener): () => void        (Svelte-compatible subscribe)
    - select(selector, eq?): Observable<T>   (derived streams)

    Notes:
    - Use BehaviorSubject so new subscribers immediately get the current value.
    - subscribe must return an unsubscribe function.

Selectors (pure functions, no RxJS):
[x] Implement selectors
    - getCurrentPage(state)
    - getShapesOnCurrentPage(state)
    - getSelectedShapes(state)

Invariants (pick "repair" and test it):
[x] Implement enforceInvariants(state): EditorState (repair strategy):
    - selectionIds := selectionIds filtered to existing shapes
    - currentPageId must exist:
        - if missing, set to first existing page
        - if no pages exist, create a default page and set it
[x] Ensure setState always runs enforceInvariants before publishing next state

Tests
[x] subscribe immediately receives current state upon subscription (BehaviorSubject behavior)
[x] subscribe fires exactly once per setState call
[x] invariants are enforced on any update (selection filtered, page fixed/created)

(DoD):
- Renderer can subscribe to state$ (or subscribe()) and redraw on any change.
- SvelteKit can bridge to runes with $effect unsubscribe cleanup.

==============================================================================
5. Milestone E: Canvas renderer (read-only)                            *wb-E*
==============================================================================

Goal: draw the document from state, no interactivity yet.

Renderer (/packages/renderer):
[x] createRenderer(canvas, store) -> { dispose() }
[x] Implement render loop strategy:
    - requestAnimationFrame redraw on "dirty" flag
    - mark dirty on store updates

[x] Implement draw pipeline:
    - clear canvas
    - apply camera transform
    - draw shapes (rect/ellipse/line/arrow/text)
    - draw selection outline if selectionIds non-empty

[x] Implement text measurement fallback:
    - if text shape has w? else measureText and derive bounds

[x] Implement pixel ratio handling:
    - set canvas width/height by devicePixelRatio
    - scale context accordingly

(DoD):
- With a hardcoded doc in the store, shapes appear at correct coordinates
  and stay stable while resizing the browser window.


==============================================================================
6. Milestone F: Hit testing (picking)                                  *wb-F*
==============================================================================

Goal: determine what the cursor is over.

Geometry (/packages/core/src/geom):
[x] shapeBounds(shape) -> Box2
[x] pointInRect(p, rectShape) -> bool
[x] pointInEllipse(p, ellipseShape) -> bool
[x] pointNearSegment(p, a, b, tolerance) -> bool
[x] hitTestPoint(state, worldPoint) -> shapeId? (topmost wins)

Layering:
[x] Define draw order = page.shapeIds order
[x] hitTest uses reverse order for topmost selection

(DoD):
- You can hover shapes and log the hit shape id (no selection yet).

==============================================================================
7. Milestone G: Input system (pointer + keyboard)                      *wb-G*
==============================================================================

Goal: normalize events into editor actions.

Input adapter (/apps/web/src/lib/input):
[x] Capture pointerdown/move/up
[x] Convert screen coords -> world coords using camera
[x] Track pointer state: isDown, startWorld, lastWorld, buttons

Keyboard:
[x] Capture keydown/keyup
[x] Normalize modifiers (ctrl/cmd, shift, alt)

Action bus (/packages/core/src/actions.ts):
[x] Define Action union:
    - PointerDown, PointerMove, PointerUp
    - KeyDown, KeyUp
    - Wheel (for zoom)
[x] dispatch(action) -> store updates via tool state machine (next milestone)

(DoD):
- You can pan/zoom camera via wheel/drag with a temporary "camera tool"
  (even before selection tool exists).


==============================================================================
8. Milestone H: Tool state machine (foundation)                        *wb-H*
==============================================================================

Goal: tools are explicit, testable state machines (RxJS based)

Tools (/packages/core/src/tools):
[x] Define ToolId: "select" | "rect" | "ellipse" | "line" | "arrow" | "text" | "pen"
[x] Define Tool interface:
    - id
    - onEnter(state)
    - onAction(state, action) -> newState
    - onExit(state)

Tool router:
[x] routeAction(state, action) -> newState (delegates to active tool)

(DoD):
- A dummy tool can consume pointer events and update state deterministically.


==============================================================================
9. Milestone I: Select/move tool (MVP interaction)                     *wb-I*
==============================================================================

Goal: select shapes and drag them.

Selection:
[x] PointerDown:
    - if hit shape: selection = [shapeId] (or add with shift)
    - else selection = []
[x] PointerMove while dragging selected:
    - translate selected shapes by deltaWorld
[x] PointerUp:
    - end drag

Marquee select (smallest slices):
[x] Implement marquee start (on empty canvas pointerdown)
[x] Render marquee rectangle overlay
[x] On pointerup, select shapes whose bounds intersect marquee

UX:
[x] Escape clears selection
[x] Delete removes selected shapes

(DoD):
- You can select and move shapes reliably.

==============================================================================
10. Milestone J: Create basic shapes via tools                         *wb-J*
==============================================================================

Goal: place shapes with dedicated tools.

Rect tool (repeat pattern for others):
[x] PointerDown on canvas:
    - create a draft rect shape with w/h=0 at startWorld
    - selection = [newId]
[x] PointerMove:
    - update w/h based on currentWorld - startWorld
[x] PointerUp:
    - if too small, delete it (click-cancel behavior)
    - else finalize

[x] Implement ellipse tool (same mechanics)
[x] Implement line tool (a=startWorld, b=currentWorld)
[x] Implement arrow tool (same as line but type="arrow")
[x] Implement text tool:
    - click to create text shape
    - open in-place editor overlay (contenteditable) in Svelte

(DoD):
- You can draw rect/ellipse/line/arrow/text on the canvas.

================================================================================
11. Milestone K: Bindings for arrows (v0)                                 *wb-K*
================================================================================

Goal: arrow endpoints can "stick" to shapes.

Binding creation:
[x] On arrow finalize:
    - hit test start/end points
    - if point hits a target shape, create binding record for that handle

Binding resolution:
[x] resolveArrowEndpoints(state, arrowId) -> { a, b } in world coords
    - if bound, compute endpoint at target shape bounds center (v0)
    - else use arrow props a/b

Live update:
[x] When a target shape moves, bound arrow rerenders automatically
    - no mutation required if resolve happens during render

(DoD):
- Arrows remain connected to moved shapes (center-to-center is fine for v0).

================================================================================
12. Milestone L: History (undo/redo)                                      *wb-L*
================================================================================

Goal: every user-visible change is undoable.

History model (/packages/core/src/history):
[x] Define Command:
    - do(state) -> state
    - undo(state) -> state

[x] Wrap mutations as commands:
    - CreateShapeCommand
    - UpdateShapeCommand (with before/after snapshot)
    - DeleteShapesCommand
    - SetSelectionCommand
    - SetCameraCommand

[x] Implement stacks:
    - undoStack, redoStack

[x] Wire shortcuts:
    - Ctrl/Cmd+Z undo
    - Ctrl/Cmd+Shift+Z redo

(DoD):
- Undo/redo works for create/move/delete and camera changes.

==============================================================================
13. Milestone M: Persistence (web) via Yjs + IndexedDB                 *wb-M*
==============================================================================

Goal: The web app persists boards locally using Yjs, with offline support via
      IndexedDB (y-indexeddb).

Web persistence primitives (/packages/core/src/persist/web):
[ ] Add deps (web build):
    - yjs
    - y-indexeddb (IndexedDB persistence provider)

[ ] Define a Yjs schema for the drawing document (doc layer only):
    - ydoc.getMap("pages"): Y.Map<pageId, PageRecord>
    - ydoc.getMap("shapes"): Y.Map<shapeId, ShapeRecord>
    - ydoc.getMap("bindings"): Y.Map<bindingId, BindingRecord>
    - ydoc.getArray("pageOrder"): Y.Array<pageId>
    - per-page shape order: ydoc.getArray(`page:${id}:shapeOrder`)

[ ] Implement WebDocRepo (board-level API):
    - listBoards(): Promise<BoardMeta[]>
    - createBoard(name): Promise<boardId>
    - openBoard(boardId): Promise<{ ydoc, provider, meta }>
    - renameBoard(boardId, name): Promise<void>
    - deleteBoard(boardId): Promise<void>

    Notes:
    - y-indexeddb persistence is keyed by a string name; use a stable boardId.
    - Keep exactly ONE IndexeddbPersistence instance per (boardId, tab) to avoid
      duplicated persistence work.

[ ] Implement a tiny "board index" for listBoards():
    - Store BoardMeta (id, name, createdAt, updatedAt) in:
        - localStorage (v0), or
        - a small IndexedDB store you control (v1)
    - Update updatedAt whenever the Y.Doc changes.

[ ] Bridge Yjs doc -> in-memory EditorState.doc snapshot:
    - Add docSubscription:
        - observe ydoc changes and rebuild/patch the in-memory doc snapshot
    - Keep UI state out of Yjs for now:
        - state.ui (selection/tool) remains local
        - state.camera remains local

[ ] Export/import (still useful for sharing/debugging):
    - exportJSON(boardId): string (serialize to your plain JSON doc model)
    - importJSON(json): createBoard + populate Y.Doc via Yjs transaction

Tests (/packages/core/test):
[ ] opening the same boardId twice reuses metadata and does not create duplicate
    persistence instances (unit test at repo layer; integration test later).
[ ] after mutating Y.Doc, closing and reopening loads the same content (offline).
    (This is the expected y-indexeddb behavior.)
[ ] board index updatedAt changes on Y.Doc update.

(DoD):
- Web app: create a board, draw, refresh page, content is still there.
- Renderer redraws when the Y.Doc changes (through your bridge layer).

==============================================================================
14. Milestone N: Desktop packaging (Tauri)                             *wb-N*
==============================================================================

Goal: same app works as a desktop app with filesystem access.

Tauri + SvelteKit integration:
[ ] Configure SvelteKit for static/SPA output
[ ] Ensure SSR is disabled for desktop build
[ ] Configure Tauri to load the built assets

File dialogs + FS:
[ ] Implement "Save As…" using Tauri dialog + fs APIs
[ ] Implement "Open…" using Tauri dialog + fs APIs
[ ] Add recent files list (v0: store paths in Tauri local storage)

(DoD):
- Desktop app opens/saves JSON files on disk and reopens them correctly.

==============================================================================
15. Milestone O: Export (PNG/SVG)                                      *wb-O*
==============================================================================

Goal: export drawings as shareable artifacts.

[ ] Implement exportViewportToPNG(canvas) (screen export)
[ ] Implement exportSelectionToPNG (render selection bounds)
[ ] Implement SVG export for basic shapes:
    - rect/ellipse/line/arrow/text
    - camera transform baked into output or removed-pick one and document

Tests:
[ ] exported SVG parses and contains expected elements

(DoD):
- One-click export works in both web and desktop.


==============================================================================
16. Milestone P: Performance + big docs (pragmatic)                    *wb-P*
==============================================================================

Goal: the editor stays responsive with many shapes.

[ ] Add spatial index (v0: simple grid buckets):
    - rebuild index on doc changes
    - query nearby shapes for hit testing

[ ] Add view culling:
    - compute viewport bounds in world space
    - render only shapes whose bounds intersect viewport

[ ] Reduce redraw frequency:
    - rAF only while dirty
    - optionally batch multiple store updates into one redraw

[ ] Add microbench harness:
    - generate 10k shapes doc
    - measure hit test and render time

(DoD):
- 10k simple shapes pans/zooms smoothly on a typical machine.


==============================================================================
17. Milestone Q: File Browser (web: Yjs/IndexedDB peek, desktop: FS)    *wb-Q*
==============================================================================

Goal: A unified "Open board" experience:
- Web: browse locally persisted Yjs boards + basic "storage inspector"
- Desktop: browse real directories/files (native file browser semantics)

------------------------------------------------------------------------------
Q1. Shared UX + contracts (core)
------------------------------------------------------------------------------

Contracts (/packages/core/src/persist):
[ ] Define BoardMeta:
    - id, name, createdAt, updatedAt
    - optional: storageKind = "web-indexeddb" | "desktop-fs"

[ ] Define DocRepo interface (implemented by web + desktop):
    - listBoards(): Promise<BoardMeta[]>
    - createBoard(name): Promise<string>
    - openBoard(id): Promise<void> (or returns handle)
    - renameBoard(id, name): Promise<void>
    - deleteBoard(id): Promise<void>

[ ] Define a FileBrowserViewModel (pure data for UI):
    - query string
    - filtered list of BoardMeta
    - selected board id
    - actions: open/create/rename/delete

(DoD):
- Svelte UI can render the browser from a single ViewModel shape.

------------------------------------------------------------------------------
Q2. Web file browser: "Boards" + IndexedDB/Yjs inspector
------------------------------------------------------------------------------

UI (/apps/web/src/lib/filebrowser):
[ ] Implement Boards panel:
    - listBoards() -> render list
    - search filter (client-side)
    - create/rename/delete
    - open on click

[ ] Implement a "Storage inspector" drawer for the selected board:
    - show boardId + y-indexeddb persistence name (same string)
    - show "synced/loaded" status from the provider lifecycle (v0: boolean)
    - show a rough persisted size indicator:
        - compute encoded state size (bytes) from Yjs state vector/update
          (v0: best-effort number; label it "approx")
    - add buttons:
        - Export JSON
        - Export "Yjs update" (debug artifact)

Svelte runes integration:
[ ] Subscribe to repo changes using $effect and cleanup unsubscribe.

(DoD):
- Web: you can browse boards, open one, and view basic persistence/debug info
  that confirms it’s backed by y-indexeddb.

------------------------------------------------------------------------------
Q3. Desktop file browser: real directory + files (Tauri)
------------------------------------------------------------------------------

Desktop behavior:
[ ] Add "Workspace folder" concept:
    - choose a directory using Tauri dialog open({ directory: true })
    - remember last workspace path (v0: local settings file)

[ ] Implement directory listing:
    - read directories + files via Tauri FS plugin APIs
    - display as:
        - v0: flat list of "*.wanderboard.json" files, or
        - v1: tree view (folders expandable)

[ ] Implement file actions:
    - New board: creates new file in workspace
    - Rename: renames file
    - Delete: deletes file
    - Open: loads file into editor

[ ] Scope/security note handling:
    - paths returned by dialog are scoped for FS access; persist the chosen
      workspace path yourself for the next launch.

(DoD):
- Desktop: pick a folder, browse files, open/save boards from disk.

------------------------------------------------------------------------------
Q4. "Parity" behaviors (web + desktop)
------------------------------------------------------------------------------

[ ] Consistent command surface:
    - Ctrl/Cmd+O opens the file browser modal
    - Ctrl/Cmd+N creates a board
    - rename/delete via context menu

[ ] Consistent metadata:
    - show updatedAt and name in both modes

(DoD):
- Switching between web and desktop feels like the same app, but the web mode
  clearly indicates "local Yjs/IndexedDB" storage, while desktop is real files.


==============================================================================
18. Milestone R: Quality polish (what makes it feel "real")            *wb-R*
==============================================================================

Goal: the UX crosses the "this is legit" threshold.

[ ] Snapping:
    - snap move to grid
    - snap to other shape edges/centers (basic)

[ ] Handles:
    - resize handles for rect/ellipse
    - rotate handle
    - cursor affordances

[ ] Keyboard affordances:
    - nudge with arrow keys
    - duplicate (Ctrl/Cmd+D)
    - bring forward/back

[ ] Accessibility:
    - tool buttons navigable with keyboard
    - visible focus states
    - ARIA labels for controls

(DoD):
- A user can comfortably draw and edit without surprises.


==============================================================================
Appendix: Suggested file layout                                   *wb-files*
==============================================================================

packages/core/src/
  actions/
  camera/
  geom/
  history/
  id/
  model/
  store/
  tools/

packages/renderer/src/
  renderer.ts
  draw/
  text/

apps/web/src/
  routes/
  lib/
    canvas/
    ui/

apps/desktop/
  src-tauri/
  (wraps web build)


==============================================================================
References (URLs)                                                   *wb-refs*
==============================================================================

tldraw conceptual references (inspiration only):
- https://tldraw.dev/docs/shapes
- https://tldraw.dev/docs/editor
- https://tldraw.dev/reference/editor/Editor

Yjs collaboration option:
- https://docs.yjs.dev/
- https://docs.yjs.dev/getting-started/working-with-shared-types
- https://github.com/yjs/yjs

SvelteKit + Tauri packaging:
- https://v2.tauri.app/start/frontend/sveltekit/
- https://svelte.dev/docs/kit/adapter-static
- https://tauri.app/v1/guides/getting-started/setup/sveltekit/

Canvas/infinite-canvas performance ideas:
- https://antv.vision/infinite-canvas-tutorial/guide/lesson-008
- https://harrisonmilbradt.com/blog/canvas-panning-and-zooming
